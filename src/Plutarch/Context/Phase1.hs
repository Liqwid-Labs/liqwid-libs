{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ViewPatterns #-}
{-# OPTIONS_GHC -Wno-all #-}

module Plutarch.Context.Phase1 (
    Checker (..),
    inOutZeroSum,
    validDatumPairs,
    positiveValues,
    signaturesProvided,
    signaturesFormat,
    validTxId,
    validInputRefId,
    credentialFormat,
    phase1Check,
    customCheck,
) where

import Data.Foldable (toList)
import Data.Validation
import Plutarch.Context.Base (BaseBuilder (..), Builder, UTXO (..), unpack)
import PlutusLedgerApi.V1
import PlutusLedgerApi.V1.Value
import qualified PlutusTx.AssocMap as AssocMap
import PlutusTx.Builtins
import Acc

{- | Possible errors from phase-1 checker

 @since 2.1.0
-}
data CheckerError
    = IncorrectByteString 
    | IncorrectOutRef
    | NoSignature
    | ExtraDatum
    | NonPositiveValue
    | NoZeroSum Value
    deriving stock (Show, Eq)

newtype Checker a =
    Checker {unChecker :: a -> Validation (Acc CheckerError) a}

{- | Checks if inputs, outputs, and minting is correct and zero sum.

 @since 2.1.0
-}
inOutZeroSum :: Builder a => a -> Validation (Acc CheckerError) a
inOutZeroSum b@(unpack -> BB{..})
    | i <> m == o <> bbFee = Success b
    | otherwise =
        Failure $ pure $ NoZeroSum (diff (i <> m <> bbFee) o)
  where
    -- TODO: This is quite wired, AssocMap doesn't implment Functor, but it does on haddock.
    diff x (Value y) = x <> Value (AssocMap.mapMaybe (Just . AssocMap.mapMaybe (Just . negate)) y)
    i = mconcat . toList $ utxoValue <$> bbInputs
    o = mconcat . toList $ utxoValue <$> bbOutputs
    m = mconcat . toList $ bbMints

{- | Checks if all TxOutRefId of TxInInfos are correct. Checker of
   TxOutRefIdx because they will be generated by the builder.

 @since 2.1.0
-}
validInputRefId :: Builder a => a -> Validation (Acc CheckerError) a
validInputRefId b@(unpack -> BB{..})
    | correct = Success b
    | otherwise = Failure $ pure $ IncorrectOutRef
  where
    correct = all (maybe False $ \(TxId x) -> lengthOfByteString x == 28) $ utxoTxId <$> bbInputs

{- | Checks if datum pairs are correct. We don't have to check actual
   TxOuts as their datum pairs are generated and thus is always correct.

 @since 2.1.0
-}
validDatumPairs :: Builder a => a -> Validation (Acc CheckerError) a
validDatumPairs b@(unpack -> BB{..})
    | null bbDatums = Success b
    | otherwise = Failure $ pure $ ExtraDatum

{- | Checks if all values from input and outputs is positive.

@since 2.1.0
-}
positiveValues :: Builder a => a -> Validation (Acc CheckerError) a
positiveValues b@(unpack -> BB{..})
    | f bbInputs && f bbOutputs = Success b
    | otherwise = Failure $ pure $ NonPositiveValue
  where
    isPos = all (\(_, _, x) -> x > 0) . flattenValue
    f = and . fmap (isPos . utxoValue)

{- | Checks if at least one signature is provided.

 @since 2.1.0
-}
signaturesProvided :: Builder a => a -> Validation (Acc CheckerError) a
signaturesProvided b@(unpack -> BB{..})
    | not $ null bbSignatures = Success b
    | otherwise = Failure $ pure $ NoSignature

{- | Checks if signatures are valid: 28 bytes long

 @since 2.1.0
-}
signaturesFormat :: Builder a => a -> Validation (Acc CheckerError) a
signaturesFormat b@(unpack -> BB{..})
    | c = Success b
    | otherwise = Failure $ pure $ IncorrectByteString
  where
    c = all (\(PubKeyHash x) -> lengthOfByteString x == 28) bbSignatures

{- | Checks if TxId is valid: 28 bytes long

 @since 2.1.0
-}
validTxId :: Builder a => a -> Validation (Acc CheckerError) a
validTxId b@(unpack -> BB{..})
    | lengthOfByteString (getTxId bbTxId) == 28 = Success b
    | otherwise = Failure $ pure $ IncorrectByteString

{- | Checks if all credentials are valid: 28 bytes long

 @since 2.1.0
-}
credentialFormat :: Builder a => a -> Validation (Acc CheckerError) a
credentialFormat b@(unpack -> BB{..})
    | f bbInputs && f bbOutputs = Success b
    | otherwise = Failure $ pure $ IncorrectByteString
  where
    bs (PubKeyCredential (PubKeyHash pkh)) = pkh
    bs (ScriptCredential (ValidatorHash vh)) = vh
    f = all (\x -> lengthOfByteString (bs x) == 28) . fmap utxoCredential

{- | Checker all phase-1 validation.

 @since 2.1.0
-}
phase1Check :: Builder a => Checker a
phase1Check =
    customCheck
        [ inOutZeroSum
        , validInputRefId
        , validDatumPairs
        , positiveValues
        , signaturesProvided
        , signaturesFormat
        , validTxId
        , credentialFormat
        ]

{- | Make custom validation with provided validation components.

 @since 2.1.0
-}
customCheck ::
    [(a -> Validation (Acc CheckerError) a)] ->
    Checker a
customCheck cks = Checker $ \x -> foldr (*>) (Success x) (($ x) <$> cks)
